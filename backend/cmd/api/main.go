// Package main is the entry point for the Naratel Box API.
//
// @title          Naratel Box API
// @version        1.0
// @description    Block-level deduplicated file storage with JWT authentication and QNAP S3 backend.
// @termsOfService http://naratel.id/terms
//
// @contact.name   Naratel Dev Team
// @contact.email  dev@naratel.id
//
// @license.name   MIT
// @license.url    https://opensource.org/licenses/MIT
//
// @host      prod3.roomify3.my.id
// @BasePath  /api/v1
//
// @securityDefinitions.apikey BearerAuth
// @in                         header
// @name                       Authorization
// @description                Enter: Bearer <your_jwt_token>
package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/go-chi/cors"
	httpSwagger "github.com/swaggo/http-swagger"

	"github.com/naratel/naratel-box/backend/internal/auth"
	"github.com/naratel/naratel-box/backend/internal/block"
	"github.com/naratel/naratel-box/backend/internal/config"
	"github.com/naratel/naratel-box/backend/internal/handler"
	"github.com/naratel/naratel-box/backend/internal/logger"
	"github.com/naratel/naratel-box/backend/internal/repository"
	"github.com/naratel/naratel-box/backend/internal/storage"

	_ "github.com/naratel/naratel-box/backend/docs" // generated by swag
)

func main() {
	// ── Config ────────────────────────────────────────────────────────────────
	cfg, err := config.Load()
	if err != nil {
		logger.Fatalf("config.Load: %v", err)
	}

	// ── Database ──────────────────────────────────────────────────────────────
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	pool, err := repository.NewPool(ctx, cfg.DSN())
	if err != nil {
		logger.Fatalf("Database connection failed: %v", err)
	}
	defer pool.Close()
	logger.Infof("Database connected successfully")

	// ── S3 Client ─────────────────────────────────────────────────────────────
	s3Client, err := storage.NewS3Client(
		cfg.S3Endpoint,
		cfg.S3AccessKey,
		cfg.S3SecretKey,
		cfg.S3Region,
		cfg.S3Bucket,
		cfg.S3ForcePathStyle,
	)
	if err != nil {
		logger.Fatalf("S3 client init failed: %v", err)
	}
	logger.Infof("S3 client ready (endpoint=%s, bucket=%s)", cfg.S3Endpoint, cfg.S3Bucket)

	// ── Repositories ──────────────────────────────────────────────────────────
	userRepo      := repository.NewUserRepository(pool)
	blockRepo     := repository.NewBlockRepository(pool)
	fileRepo      := repository.NewFileRepository(pool)
	folderRepo    := repository.NewFolderRepository(pool)
	shareLinkRepo := repository.NewShareLinkRepository(pool)

	// ── Block Processor ───────────────────────────────────────────────────────
	processor := block.NewProcessor(cfg.BlockSizeBytes(), blockRepo, s3Client)

	// ── Handlers ──────────────────────────────────────────────────────────────
	authHandler     := handler.NewAuthHandler(userRepo, cfg.JWTSecret, cfg.JWTExpiryHours)
	uploadHandler   := handler.NewUploadHandler(fileRepo, processor)
	downloadHandler := handler.NewDownloadHandler(fileRepo, blockRepo, s3Client)
	folderHandler   := handler.NewFolderHandler(folderRepo, fileRepo)
	shareHandler    := handler.NewShareHandler(shareLinkRepo, fileRepo, blockRepo, s3Client)

	// ── Chi Router ────────────────────────────────────────────────────────────
	r := chi.NewRouter()

	// Global middleware
	r.Use(middleware.Recoverer)
	r.Use(logger.Middleware)
	r.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{"*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Origin", "Content-Type", "Accept", "Authorization"},
		AllowCredentials: false,
		MaxAge:           300,
	}))

	// ── Routes ────────────────────────────────────────────────────────────────
	r.Route("/api/v1", func(api chi.Router) {
		// Public auth
		api.Post("/auth/register", authHandler.Register)
		api.Post("/auth/login", authHandler.Login)

		// Public share link download
		api.Get("/share/{token}", shareHandler.DownloadShared)

		// Protected auth
		api.With(auth.Middleware(cfg.JWTSecret)).Get("/auth/me", authHandler.Me)

		// Protected file routes
		api.Group(func(files chi.Router) {
			files.Use(auth.Middleware(cfg.JWTSecret))
			files.Post("/files", uploadHandler.Upload)
			files.Get("/files", uploadHandler.ListFiles)
			files.Get("/files/{id}/info", uploadHandler.FileInfo)
			files.Get("/files/{id}", downloadHandler.Download)
			files.Delete("/files/{id}", downloadHandler.DeleteFile)
			files.Patch("/files/{id}/rename", uploadHandler.RenameFile)
			files.Patch("/files/{id}/move", uploadHandler.MoveFile)

			// Share links
			files.Post("/files/{id}/share", shareHandler.CreateShareLink)
			files.Get("/files/{id}/share", shareHandler.GetShareLinks)
			files.Delete("/share/{linkId}", shareHandler.DeleteShareLink)
		})

		// Protected folder routes
		api.Group(func(folders chi.Router) {
			folders.Use(auth.Middleware(cfg.JWTSecret))
			folders.Post("/folders", folderHandler.CreateFolder)
			folders.Get("/folders/contents", folderHandler.ListFolderContents)
			folders.Get("/folders/all", folderHandler.ListAllFolders)
			folders.Get("/folders/{id}/breadcrumb", folderHandler.Breadcrumb)
			folders.Patch("/folders/{id}/rename", folderHandler.RenameFolder)
			folders.Patch("/folders/{id}/move", folderHandler.MoveFolder)
			folders.Delete("/folders/{id}", folderHandler.DeleteFolder)
		})
	})

	// Health check
	r.Get("/health", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		w.Write([]byte(`{"status":"ok"}`))
	})

	// Swagger UI — available at http://localhost:8080/swagger/index.html
	r.Get("/swagger/*", httpSwagger.WrapHandler)

	// ── HTTP Server ───────────────────────────────────────────────────────────
	addr := fmt.Sprintf(":%s", cfg.AppPort)
	srv := &http.Server{
		Addr:         addr,
		Handler:      r,
		ReadTimeout:  10 * time.Minute,
		WriteTimeout: 10 * time.Minute,
		IdleTimeout:  2 * time.Minute,
	}

	// ── Graceful Shutdown ─────────────────────────────────────────────────────
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

	go func() {
		logger.Infof("Naratel Box API running on http://localhost%s", addr)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			logger.Fatalf("Server error: %v", err)
		}
	}()

	<-quit
	logger.Infof("Shutting down gracefully...")
	shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer shutdownCancel()
	if err := srv.Shutdown(shutdownCtx); err != nil {
		logger.ErrorLog(context.Background(), "Shutdown error", logger.ErrorDetails{
			Code: "SHUTDOWN_ERR", Details: err.Error(),
		})
	}
	logger.Infof("Server stopped")
}
